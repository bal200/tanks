<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Bals game</title>
        <script src="phaser\build\phaser.js"></script>
    </head>
    <body>

    <script type="text/javascript">

    

// Phaser current version test environment
// Smoothed camera with parallax scrolling 

var game = new Phaser.Game(800, 600, Phaser.WEBGL, 'Tanks');

var BasicGame = function(game) {};

BasicGame.Boot = function (game) {
    // nothing here
};

var cameraMidPos = new Phaser.Point(0, 0);  /* my camera */
var bitmap;
var worldScale = 1;
var level = {
  x:0,  y:-1024,  /* world size */
  x2:2048, y2:2048,
  bgPercent : 0.15, /** This percentage of the main screen Scale will be used as the Backgrounds scale.
                     ** Small values = a slow moving distant background */
  bgOffset: 350   /** Because the background maths is calculated from the screen middle, you may need to
                   ** pull the background more to the left and the top. Tweak this to make sure the
                   ** background neatly covers the whole world.*/
}
BasicGame.Boot.prototype = 
{
    preload: function() {
      game.time.advancedTiming = true;
      game.load.image("background", "background.png");
      //game.load.image("star", "assets/star.png");
      
    },
	create: function() 
	{
        // generate a background so we can see the world/camera movement

        //this.bg = game.add.tileSprite(0, 0, 878, 653, 'background');
        this.bg = game.add.sprite(0, 0, 'background');

        //this.bg.fixedToCamera = true;
        //this.bg.tileScale.set(0.5);
        //this.bg.tint = 0x660000;
        
        this.bitmap = this.make.bitmapData(2048,1024);
        //this.foreground = this.add.bitmapData(1024, 1024, null, true);
        
        buildMap(this.bitmap);
        this.foreground = game.add.image(0, 0, this.bitmap);
        //this.foreground.fixedToCamera = true;
        //this.bgnear.tint = 0xcc4400;
        
        
        /*** Hero ***/
        this.player = game.add.group();
        this.player.speed = 5;
        
        var playerGraphics = game.add.graphics();
        playerGraphics.beginFill(0x00ffff);
        playerGraphics.drawCircle(0, 0, 16);
        this.player.add(playerGraphics);
        
        this.cursors = this.input.keyboard.createCursorKeys();
        this.fireButton = this.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
        this.fireButton.onDown.add(this.fire, this);
        
        this.game.world.setBounds(level.x,level.y, level.x2,level.y2);
        cameraMidPos.setTo(this.player.x, this.player.y);
        //this.game.camera.reset();
        
        function buildMap(bitmap) {
          for (var n=0; n<1024; n+=64) {
            bitmap.rect(n+0, 0, 32, 32, '#cc4400');
            bitmap.rect(n+32, 32, 32, 32, '#cc4400');
          }
          for (var n=0; n<2048; n+=64) {
            var col = '#cc4400';
            if (n>=1024)  col='#0044cc';
            bitmap.rect(n+0, 512+0, 32, 32, col);
            bitmap.rect(n+32, 512+32, 32, 32, col);
          }
        }
    },
    fire: function () {
      var x = this.player.x;
      var y = this.player.y;
      //this.bitmap.draw('star', x,y);
      this.bitmap.blendDestinationOut();
      this.bitmap.circle(x, y, 16);
      this.bitmap.blendReset();
      //this.bitmap.update();
      this.bitmap.dirty = true;
      //this.bitmap.render();
      
    },
    update: function() 
    {
        if (this.cursors.left.isDown) {
            this.player.x -= this.player.speed; }
        else if (this.cursors.right.isDown) {
            this.player.x += this.player.speed; }
        if (this.cursors.up.isDown) {
            this.player.y -= this.player.speed; }
        else if (this.cursors.down.isDown) {
            this.player.y += this.player.speed; }
        // zoom
        if (game.input.keyboard.isDown(Phaser.Keyboard.Q)) {
            worldScale += 0.01; }
        else if (game.input.keyboard.isDown(Phaser.Keyboard.A)) {
            worldScale -= 0.01;
        }


        // change this value to alter the amount of damping, lower values = smoother camera movement
        var lerp = 0.1;
        /* calc middle point of camera in world coords */
        cameraMidPos.x += (this.player.x - cameraMidPos.x) * lerp; /* find the screen middle in World */
        cameraMidPos.y += (this.player.y - cameraMidPos.y) * lerp;
        
        var dist = Math.abs( cameraMidPos.distance(this.player) );
        var target = 1/ (1.0 + (dist*0.007));
        scaleDif = target - worldScale;
        worldScale += scaleDif * 0.01;/* lerp */
        
        // set a minimum and maximum scale value
        worldScale = Phaser.Math.clamp(worldScale, 0.50, 1.2);
        
        // set our world scale as needed
        game.world.scale.set(worldScale);
        
        /* Note: screen width including scaling is (game.width/worldScale)  */
        var screenSizeScaled = new Phaser.Point(game.width/worldScale,
                                                game.height/worldScale);
 

        /* work out camera offset, based on Scale, and camera coords are for top left of camera */
        /* Camera middle - half screen width, allowing for scaling of screen too */
        game.world.pivot.x = cameraMidPos.x - (screenSizeScaled.x /2);
        game.world.pivot.y = cameraMidPos.y - (screenSizeScaled.y /2);
        /* Limit camera to world bounds */
        game.world.pivot.x = Phaser.Math.clamp(game.world.pivot.x, level.x, level.x2 - screenSizeScaled.x);
        game.world.pivot.y = Phaser.Math.clamp(game.world.pivot.y, level.y, level.y2 - screenSizeScaled.y);
        
        //this.game.camera.focusOnXY(cameraMidPos.x, cameraMidPos.y);

        
        
        /* Work out Camera Middle again, but this time it will include any Clamping */
        var newCamMid = new Phaser.Point(game.world.pivot.x + (screenSizeScaled.x /2),
                                         game.world.pivot.y + (screenSizeScaled.y /2));

        var bgPercent = level.bgPercent;
        /** A percentage of the main screen Scale will be the Backgrounds scale.
         ** small values = slow, distant looking background */
        var bgScale =  (1/worldScale) * reduceAScale(worldScale, bgPercent);
        /* the (1/worldscale) effectively cancels out the worldscale already in the translation */
        this.bg.scale.set(  bgScale  );
        
        var bgOffset = level.bgOffset;

        this.bg.position.set(newCamMid.x /* start from screen middle, this value doesnt get scaled */
                              -(( (newCamMid.x*bgPercent) +bgOffset ) *bgScale),
                           /* take off to pull bg to the left:
                            *  a small percentage of camera position, so it moves slower
                            *  add an offset to account for the black on left and top edges,
                            *  then multiply by the backgrounds scale from above */
                            
                            (newCamMid.y)
                              -(( (newCamMid.y*bgPercent)+bgOffset ) * bgScale) );



        function reduceAScale(scale, ratio) {
          return ((scale-1)*ratio) +1;
        }
    }, 
    render: function()
    {
        game.debug.text(game.time.fps+"fps "
                        +"cam "+game.camera.x+","+game.camera.y+" "
                        +"myCam "+game.world.pivot.x.toFixed(0)+","+game.world.pivot.y.toFixed(0)+" "
                        //+game.player.x+","+game.player.y+" "
                        +"scale "+worldScale.toFixed(2)
                        || '--', 2, 14, "#00ff00");   
    }
};



game.state.add('Boot', BasicGame.Boot);
game.state.start('Boot');
    

    </script>

    </body>
</html>