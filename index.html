<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
        <title>Bals game</title>
        <!-- use local Phaser Lib -->
        <script src="phaser\build\phaser.js"></script>
        <!-- use CDN Phaser Lib -->
        <!-- <script src="//cdn.jsdelivr.net/phaser/2.2.2/phaser.min.js"></script>  -->
    </head>
    <body>
    <script type="text/javascript">


// Smoothed camera with parallax scrolling 

var game = new Phaser.Game(800, 600, Phaser.WEBGL, 'Tanks');

var BasicGame = function(game) {};

BasicGame.Boot = function (game) {
    // nothing here
};
/***** My Camera initialisation **********/
var cameraMidPos = new Phaser.Point(0, 0);  /* my camera */
var worldScale = 1;

var bitmap;
var level = {
  x:0,  y:-1024,  /* world size */
  x2:2048, y2:2048,
  bgPercent : 0.15,  /** This percentage of the main screen Scale will be used as the Backgrounds scale.
                      ** Small values = a slow moving distant background */
  bgOffset:{      /** Because the background maths is calculated from the screen middle, you may need to */
    x:390, y:480  /** pull the background to the left and to the top. Tweak this to make sure the      */
  }               /** background neatly covers the whole world. */ 
}

BasicGame.Boot.prototype = 
{
  preload: function() {
    game.time.advancedTiming = true;
    game.load.image("background", "background 1139x892.png");
    game.load.image("star", "assets/star.png");
    
    game.load.tilemap('tilemap', 'assets/tilemap.json', null, Phaser.Tilemap.TILED_JSON);
    game.load.image('jungletileset', 'assets/jungletileset.png');
    
  },
	create: function() 
	{
    /******* Parallax Background ********/

    //this.bg = game.add.tileSprite(0, 0, 878, 653, 'background');
    this.bg = game.add.sprite(0, 0, 'background');
    //this.bg.fixedToCamera = true;
    //this.bg.tileScale.set(0.5);
    //this.bg.tint = 0x660000;


    /*****  Foreground (Land) **********/    
      
      this.tilemap = this.add.tilemap('tilemap');
      //this.tilemap = new Phaser.Tilemap(game,'tilemap');
                               /* name in map data,  cache image name to use */
      this.tilemap.addTilesetImage('jungletileset', 'jungletileset');

      this.layer = this.tilemap.createLayer('Tile Layer 1');

    this.bitmap = this.make.bitmapData(2048,1024);
    this.count = 0;
    //buildMap(this.bitmap);
     
//    this.bitmap.draw( this.layer );
//    this.foreground = game.add.image(0, 0, this.bitmap);
//    this.layer.destroy();
    //this.foreground.fixedToCamera = true;
    //this.bgnear.tint = 0xcc4400;
    
    
    /******* Player ********************/
    this.player = game.add.group();
    this.player.speed = 5;
    
    var playerGraphics = game.add.graphics();
    playerGraphics.beginFill(0x00ffff);
    playerGraphics.drawCircle(0, 0, 16);
    this.player.add(playerGraphics);
    
    this.cursors = this.input.keyboard.createCursorKeys();
    this.fireButton = this.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
    this.fireButton.onDown.add(this.fire, this);
    
    this.game.world.setBounds(level.x,level.y, level.x2,level.y2);
    
    /****** My Camera *****************/
    cameraMidPos.setTo(this.player.x, this.player.y);
    //this.game.camera.reset();
    
    function buildMap(bitmap) {
      
    }
  },
  fire: function () {
    var x = this.player.x;
    var y = this.player.y;
    //this.bitmap.draw('star', x,y);
    this.bitmap.blendDestinationOut();
    this.bitmap.circle(x, y, 16);
    this.bitmap.blendReset();
    //this.bitmap.update();
    this.bitmap.dirty = true;
    //this.bitmap.render();
    
  },
  update: function() 
  {
    if (this.cursors.left.isDown) {
        this.player.x -= this.player.speed; }
    else if (this.cursors.right.isDown) {
        this.player.x += this.player.speed; }
    if (this.cursors.up.isDown) {
        this.player.y -= this.player.speed; }
    else if (this.cursors.down.isDown) {
        this.player.y += this.player.speed; }
    // zoom
    if (game.input.keyboard.isDown(Phaser.Keyboard.Q)) {
        worldScale += 0.01; }
    else if (game.input.keyboard.isDown(Phaser.Keyboard.A)) {
        worldScale -= 0.01;
    }

    /********** Foreground ********************/
    if (++this.count == 3) {
      this.bitmap.draw( this.layer );
      this.foreground = game.add.image(0, 0, this.bitmap);
      this.layer.destroy();
    }
    
    /********** My Camera **************************************/
    // change this value to alter the amount of damping, lower values = smoother camera movement
    var lerp = 0.1;
    /* calc middle point of camera in world coords */
    cameraMidPos.x += (this.player.x - cameraMidPos.x) * lerp; /* find the screen middle in World */
    cameraMidPos.y += (this.player.y - cameraMidPos.y) * lerp;
    
      var dist = Math.abs( cameraMidPos.distance(this.player) );
      var target = 1/ (1.0 + (dist*0.007));
      scaleDif = target - worldScale;
      worldScale += scaleDif * 0.01;/* lerp */
      
    // set a minimum and maximum scale value
    worldScale = Phaser.Math.clamp(worldScale, 0.50, 1.2);
    
    // set our world scale
    game.world.scale.set(worldScale);
    
    /* Note: screen width including scaling is (game.width/worldScale)  */
    var screenSizeScaled = new Phaser.Point(game.width/worldScale,
                                            game.height/worldScale);


    /* work out camera offset, based on Scale, and camera coords are for top left of camera */
    /* Camera middle - half screen width, allowing for scaling of screen too */
    game.world.pivot.x = cameraMidPos.x - (screenSizeScaled.x /2);
    game.world.pivot.y = cameraMidPos.y - (screenSizeScaled.y /2);
    /* Limit camera to world bounds */
    game.world.pivot.x = Phaser.Math.clamp(game.world.pivot.x, level.x, level.x2 - screenSizeScaled.x);
    game.world.pivot.y = Phaser.Math.clamp(game.world.pivot.y, level.y, level.y2 - screenSizeScaled.y);
    
    //this.game.camera.focusOnXY(cameraMidPos.x, cameraMidPos.y);

    
    /******** Parallax Background **********************************/
    /* Work out Camera Middle again, but this time it will include any Clamping */
    var newCamMid = new Phaser.Point(game.world.pivot.x + (screenSizeScaled.x /2),
                                     game.world.pivot.y + (screenSizeScaled.y /2));

    var bgPercent = level.bgPercent;
    /** A percentage of the main screen Scale will be the Backgrounds scale.
     ** small values = slow, distant looking background */
    var bgScale =  (1/worldScale) * reduceAScale(worldScale, bgPercent);
    /* the (1/worldscale) effectively cancels out the worldscale already in the translation */
    this.bg.scale.set(  bgScale  );
    
    var bgOffset = level.bgOffset;

    this.bg.position.set(newCamMid.x /* start from screen middle, this value doesnt get scaled */
                          -(( (newCamMid.x*bgPercent) +bgOffset.x ) *bgScale),
                       /* take off to pull bg to the left:
                        *  a small percentage of camera position, so it moves slower
                        *  add an offset to account for the black on left and top edges,
                        *  then multiply by the backgrounds scale from above */
                        
                        (newCamMid.y) /* same for Y */
                          -(( (newCamMid.y*bgPercent)+bgOffset.y ) * bgScale) );



    function reduceAScale(scale, ratio) {
      return ((scale-1)*ratio) +1;
    }
  }, 
  render: function()
  {
      game.debug.text(game.time.fps+"fps "
                      +"cam "+game.camera.x+","+game.camera.y+" "
                      +"myCam "+game.world.pivot.x.toFixed(0)+","+game.world.pivot.y.toFixed(0)+" "
                      //+game.player.x+","+game.player.y+" "
                      +"scale "+worldScale.toFixed(2)
                      || '--', 2, 14, "#00ff00");   
  }
};



game.state.add('Boot', BasicGame.Boot);
game.state.start('Boot');


 

    </script>
    </body>
</html>